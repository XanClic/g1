#!/usr/bin/env ruby

require 'json'


Dir.chdir(ARGV[0])

structs = {}
Dir.entries('json-structs').each do |e|
    next unless e =~ /\.json$/
    structs[e.sub(/\.json$/, '')] = JSON.parse(IO.read("json-structs/#{e}"))
end

enums = {}
Dir.entries('json-enums').each do |e|
    next unless e =~ /\.json$/
    enums[e.sub(/\.json$/, '')] = JSON.parse(IO.read("json-enums/#{e}"))
end


def interpret_array(type)
    if !type.kind_of?(Hash) || !type['of']
        throw 'The array type needs an enclosed type'
    end

    "std::vector<#{ctype(type['of'])}>"
end

$builtin = ['single', 'vec3', 'string', 'array']
$builtin_type_map = {
    'single' => 'float',
    'vec3'   => 'dake::math::vec3',
    'string' => 'std::string',
    'array'  => :interpret_array
}


def get_complex_type_dependencies(type)
    if type.kind_of?(String)
        deps = [type]
    elsif type.kind_of?(Hash)
        deps = get_complex_type_dependencies(type['type'])
        if type['type'] == 'array'
            deps += get_complex_type_dependencies(type['of'])
        end
    else
        throw "Invalid type specification #{type.inspect}"
    end

    return deps - $builtin
end

def get_dependencies(members)
    members.map { |name, type|
        get_complex_type_dependencies(type)
    }.flatten
end


struct_dependencies = {}
structs.each_key do |struct|
    struct_dependencies[struct] =
        get_dependencies(structs[struct]) - enums.keys
end


struct_order = []
while struct_order.size < structs.size
    structs_added = 0
    struct_dependencies.each do |struct, depends|
        if !struct_order.include?(struct) &&
           (struct_order & depends) == depends
            struct_order << struct
            structs_added += 1
        end
    end

    break if structs_added == 0
end

if struct_order.size < structs.size
    $stderr.puts <<EOF
Unfulfilled dependencies!
Cannot fulfill:
#{structs.keys * ', '}
EOF
end


def enum_to_cxx(elements)
    elements.map { |e|
        if e.kind_of?(String)
            "    #{e},"
        elsif e.kind_of?(Hash)
            if !e['name'] || !e['alias']
                throw "Name or alias missing in #{e.inspect}"
            end

            "    #{e['name']} = #{e['alias']},"
        else
            throw "Invalid enum element #{e.inspect}"
        end
    } * "\n"
end

def enums_to_cxx(enums)
    (enums.map { |enum, elements|
        <<EOF
enum #{enum} {
#{enum_to_cxx(elements)}
};
EOF
    } * "\n").strip
end


def first_level_type(type)
    if type.kind_of?(String)
        return type
    elsif type.kind_of?(Hash)
        if !type['type']
            throw "Complex type #{type.inspect} missing a “type” field"
        end

        return type['type']
    else
        throw "Invalid type specification #{type.inspect}"
    end
end

def array_type_and_level(type)
    flt = first_level_type(type)
    if flt != 'array'
        return [0, flt]
    else
        atl = array_type_and_level(type['of'])
        return [atl[0] + 1, atl[1]]
    end
end

def ctype(type)
    actual_type = first_level_type(type)

    if $builtin_type_map[actual_type]
        builtin = $builtin_type_map[actual_type]
        if builtin.kind_of?(String)
            converted = builtin
        elsif builtin.kind_of?(Symbol)
            converted = Kernel.send(builtin, type)
        else
            throw "Invalid builtin type definition #{builtin.inspect}"
        end
    else
        converted = actual_type
    end

    return converted
end

def struct_to_cxx(fields)
    fields.map { |name, type|
        ct = ctype(type)
        array_depth = ct.count('<')
        $max_array_depth = array_depth if array_depth > $max_array_depth
        "    #{ct} #{name};"
    } * "\n"
end

def structs_to_cxx(structs, order)
    (order.map { |struct|
        <<EOF
struct #{struct} {
#{struct_to_cxx(structs[struct])}
};
EOF
    } * "\n").strip
end


cxxenums = enums_to_cxx(enums)

$max_array_depth = 0
cxxstructs = structs_to_cxx(structs, struct_order)


header = File.open("#{ARGV[1]}/include/json-structs.hpp", 'w')
header.write <<EOF
// Auto-generated by tools/generate-serializer.rb; DO NOT EDIT

#ifndef JSON_STRUCTS_HPP
#define JSON_STRUCTS_HPP

#include <dake/math/matrix.hpp>

#include <string>
#include <vector>

#include "generic-data.hpp"


// enums

#{cxxenums}


// structs

#{cxxstructs}


// functions

#{
    (enums.keys + structs.keys).map { |t|
        "void #{t}_parse(#{t} *output, const GDData *input);"
    } * "\n"
}

#endif
EOF
header.close


serializer = File.open("#{ARGV[1]}/serializer.cpp", 'w')
serializer.write <<EOF
// Auto-generated by tools/generate-serializer.rb; DO NOT EDIT

#include <cstddef>
#include <cstring>
#include <tuple>
#include <stdexcept>
#include <string>

#include "generic-data.hpp"
#include "json.hpp"
#include "json-structs.hpp"

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
#endif
EOF

enums.each do |name, values|
    serializer.write <<EOF


static const std::pair<#{name}, const char *> #{name}_assoc[] = {
EOF
    values.each do |v|
        if v.kind_of?(String)
            serializer.write("    std::pair<#{name}, const char *>(#{v}, \"#{v}\"),\n")
        else
            serializer.write("    std::pair<#{name}, const char *>(#{v['name']}, \"#{v['name']}\"),\n")
        end
    end
    serializer.write("};\n\n")
    serializer.write <<EOF
void #{name}_parse(#{name} *obj, const GDData *d)
{
    if (d->type != GDData::STRING) {
        throw std::runtime_error("Enum values (#{name}) must be strings");
    }

    const GDString &s = *d;
    for (size_t i = 0; i < ARRAY_SIZE(#{name}_assoc); i++) {
        if (!strcmp(s.c_str(), #{name}_assoc[i].second)) {
            *obj = static_cast<#{name}>(#{name}_assoc[i].first);
            return;
        }
    }

    throw std::runtime_error("Value specified for #{name} is invalid: " + s);
}
EOF
end

serializer.write <<EOF



static void single_parse(float *obj, const GDData *d) __attribute__((unused));
static void single_parse(float *obj, const GDData *d)
{
    if (d->type != GDData::FLOAT && d->type != GDData::INTEGER) {
        throw std::runtime_error("Value given for a single is not a float or "
                                 "integer");
    }

    if (d->type == GDData::FLOAT) {
        *obj = (GDFloat)*d;
    } else /* GDData::INTEGER */ {
        *obj = (GDInteger)*d;
    }
}


static void vec3_parse(dake::math::vec3 *obj, const GDData *d) __attribute__((unused));
static void vec3_parse(dake::math::vec3 *obj, const GDData *d)
{
    if (d->type != GDData::ARRAY) {
        throw std::runtime_error("Value given for vec3 is not an array");
    }

    const GDArray &a = *d;

    if (a.size() != 3) {
        throw std::runtime_error("Array given for vec3 does not have exactly "
                                 "three arguments");
    }

    single_parse(&obj->x(), &a[0]);
    single_parse(&obj->y(), &a[1]);
    single_parse(&obj->z(), &a[2]);
}


static void string_parse(std::string *obj, const GDData *d) __attribute__((unused));
static void string_parse(std::string *obj, const GDData *d)
{
    if (d->type != GDData::STRING) {
        throw std::runtime_error("Value given for string is not a string");
    }

    *obj = (GDString)*d;
}
EOF

$max_array_depth.times do |ad|
    type = 'std::vector<' * (ad + 1) + 'T' + '>' * (ad + 1)

    serializer.write <<EOF


template<typename T>
static void array_parse_#{ad}(#{type} *obj,
    const GDData *d, void (*parse_element)(T *obj, const GDData *d))
    __attribute__((unused));
template<typename T>
static void array_parse_#{ad}(#{type} *obj,
    const GDData *d, void (*parse_element)(T *obj, const GDData *d))
{
    if (d->type != GDData::ARRAY) {
        throw std::runtime_error("Value given for an array is not an array");
    }

    const GDArray &a = *d;
    size_t element_count = a.size();
    new (obj) #{type}(element_count);

    for (size_t i = 0; i < element_count; i++) {
        #{
            ad == 0 \
                ? "parse_element(&(*obj)[i], &a[i]);" \
                : "array_parse_#{ad - 1}(&(*obj)[i], &a[i], parse_element"
        }
    }
}
EOF
end


structs.each do |struct, fields|
    serializer.write <<EOF


void #{struct}_parse(#{struct} *obj, const GDData *d)
{
    if (d->type != GDData::OBJECT) {
        throw std::runtime_error("Struct values (#{struct}) must be objects");
    }

    const GDObject &o = *d;
EOF
    fields.each do |name, type|
        serializer.write <<EOF

    auto #{name}_di = o.find(\"#{name}\");
    if (#{name}_di == o.end()) {
        throw std::runtime_error("Missing value for #{struct}.#{name}");
    }
    const GDData *#{name}_d = #{name}_di->second;
EOF
        actual_type = first_level_type(type)
        if actual_type == 'array'
            atl = array_type_and_level(type)
            serializer.write <<EOF
    array_parse_#{atl[0] - 1}(&obj->#{name}, #{name}_d,
        &#{atl[1]}_parse);
EOF
        else
            serializer.write <<EOF
    #{actual_type}_parse(&obj->#{name}, #{name}_d);
EOF
        end
    end
    serializer.write("}\n")
end

serializer.close
